\section{Introduction}

IPv6 over Low-power Wireless Personal Area Networks (6LoWPAN\footnote{We use the acronym 6LoWPAN to refer to Low power Wireless Personal Area Networks that use IPv6}) is a working group inspired by the idea that even the smallest low-power devices should be able to run the Internet Protocol to become part of the Internet of Things. The main function of a low-power wireless network is usually some sort of data collection. Applications based on data collection are plentiful, examples include environment monitoring~\cite{Tolle:2005}, field surveillance~\cite{Vicaire:2009}, and scientific observation~\cite{Werner-Allen:2006}. In order to perform data collection, a cycle-free graph structure is typically maintained and a convergecast is implemented on this network topology. Many operating systems for sensor nodes (e.g. Tiny OS~\cite{Levis2005} and Contiki OS~\cite{Dunkels:2004}) implement mechanisms (e.g. Collection Tree Protocol (CTP)~\cite{Fonseca:2009} or the IPv6 Routing Protocol for Low-Power and Lossy Networks (RPL)~\cite{rfc6550}) to maintain cycle-free network topologies to support data-collection applications.

In some situations, however, data flow in the opposite direction --- from the root, or the border router, towards the leaves becomes necessary. These situations might arise in network configuration routines, specific data queries, or applications that require reliable data transmissions with acknowledgments. Standard routing protocols for low-power wireless networks, such as CTP (Collection Tree Protocol~\cite{Fonseca:2009}) and RPL (IPv6 Routing Protocol for Low-Power and Lossy Networks~\cite{rfc6550}), have two distinctive characteristics: communication devices use unstructured IPv6 addresses that do not reflect the topology of the network (typically derived from their MAC addresses), and routing lacks support for any-to-any communication since it is based on distributed collection tree structures focused on bottom-up data flows (from the leaves to the root).

 The specification of RPL defines two modes of operation for top-down data flows: the non-storing mode, which uses source routing, and the storing mode, in which each node maintains a routing table for all possible destinations. This requires $O(n)$ space (where $n$ is the total number of nodes), which is unfeasible for memory-constrained devices. Our experiments show that in random topologies with one hundred nodes, with no link or node failures, RPL succeeds to deliver less than 20\% of top-down messages sent by the root (see Figure~\ref{fig:txdwn}).

Some works have addressed this problem from different perspectives~\cite{Rein12, Duque13, xctp}. CBFR~\cite{Rein12} is a routing scheme that builds upon collection protocols to enable point-to-point communication. Each node in the collection tree stores the addresses of its direct and indirect child nodes using Bloom filters to save memory space. ORPL~\cite{Duque13} also uses bloom filters and brings opportunistic routing to RPL to decrease control traffic overload. Both protocols suffer from false positives problem, which arises from the use of Bloom filters. \textcolor{blue}{Even though CTP does not support any-to-any traffic, XCTP \cite{xctp}, an extension of this protocol, uses opportunistic and reverse-path routing to enable bi-directional communication in CTP. XCTP is efficient in terms of message overload, but exhibits the problem of high memory footprint.}

In this work, we build upon the idea of using hierarchical IPv6 address allocation that
explores cycle-free network structures and propose Matrix, a routing scheme for dynamic network topologies and fault-tolerant any-to-any data flows in 6LoWPAN. Matrix assumes that there is an underlying collection tree topology (provided by CTP or RPL, for instance), in which nodes have static locations, i.e., are not mobile, and links are dynamic, i.e., nodes might choose different parents according to link quality dynamics. Therefore, Matrix is an overlay protocol that allows any low-power wireless routing protocol to become part of the Internet of Things. Matrix uses only one-hop information in the routing tables, which makes the protocol scalable to extensive networks. In addition, Matrix implements a local broadcast mechanism to forward messages to the right subtree when node or link failures occur. Local broadcast is activated by a node when it fails to forward a message to the next hop (subtree) in the address hierarchy.

\textcolor{blue}{After the network has been initialized and all nodes have received an IPv6 address range, three simultaneous distributed trees are maintained by all nodes: the collection tree (Ctree), the IPv6 address tree (IPtree), and the reverse collection tree (RCtree). The Ctree is built and maintained by a collection protocol (in our case, CTP). It is a minimum cost tree to nodes that advertise themselves as tree roots. The IPtree is built by Matrix over the first stable version of the Ctree in the reverse direction, i.e., nodes in the Ctree receive an hierarchical IPv6 address from root to leaves, originating a static structure. Since the Ctree is dynamic, i.e., links might change due to link qualities, at some point in the execution the IPtree no longer corresponds to the reverse Ctree. Therefore, the RCtree is created to reflect the dynamics of the collection tree in the reverse direction.}

Initially, any-to-any packet forwarding is performed using Ctree for bottom-up, and IPtree for top-down data flows. Whenever a node or link fails or Ctree changes, the new link is added in the reverse direction into RCtree, and it remains as long as this topology change persists. Top-down data packets are then forwarded from IPtree to RCtree via a local broadcast. Whenever a node receives a local-broadcast message, it checks whether it knows the subtree of the destination IPv6 address: if yes then the node forwards the packet to the right subtree via RCtree and the packet continues its path in the IPtree until the final destination.

We evaluated the proposed protocol both analytically and by simulation. Even though Matrix is platform-independent, we implemented it as a subroutine of CTP on TinyOS and conducted simulations on TOSSIM.  Matrix's memory footprint at each node is $O(k)$, where $k$ is the number of children at any given moment in time, in contrast to $O(n)$ of RPL, where $n$ is the size of the subtree rooted at each routing node. Furthermore, we show that the probability of a message to be forwarded to the destination node is high, even if a link or node fails, as long as there is a valid path, due to the geometric properties of wireless networks. Simulation results show that, when it comes to any-to-any communication, Matrix presents significant gains in terms of reliability (high any-to-any message delivery) and scalability (presenting a constant, as opposed to linear, memory complexity at each node) at a moderate cost of additional control messages, when compared to other state-of-the-art protocols, such as XCTP and RPL. \textcolor{blue}{In addition, when compared to our any-to-any routing scheme, the reverse-path routing is more efficient in terms of control traffic. However, the performance of XCTP is highly dependent on the number of data flows, and can be highly degraded when the application requires more flows or the top-down messages are delayed.}

To sum up, Matrix achieves the following essential goals that motivated our work:
\begin{itemize}
  \item \textbf{Any-to-any routing}: Matrix enables end-to-end connectivity between hosts located within or outside the 6LoWPAN.

  \item \textbf{Memory efficiency}: Matrix uses compact routing tables and, therefore, is scalable to extensive networks and does not depend on the number of flows in the network.

  \item \textbf{Reliability}: Matrix achieves $99\%$ delivery without end-to-end mechanisms, and delivers $\geq 90\%$ of end-to-end packets when a route exists under challenging network conditions.

  \item \textbf{Communication efficiency}: Matrix uses adaptive beaconing based on Trickle algorithm \cite{Levis:2004} to minimize the number of control messages in dynamic network topologies (except with node mobility).

  \item \textbf{Hardware independence}: Matrix does not rely on specific radio chip features, and only assumes an underlying collection tree structure.

  \item \textbf{IoT integration}: Matrix allocates global (and structured) IPv6 addresses to all nodes, which allow nodes to act as destinations integrated into the Internet, contributing to the realization of the Internet of Things.
\end{itemize}

The rest of this paper is organized as follows. In Section~\ref{sec:matrix}, we describe the Matrix protocol design. In Section~\ref{sec:analysis}, we analyze the message complexity of the protocol. In Section~\ref{sec:results}, we present our analytic and simulation results. In Section~\ref{sec:related}, we discuss some related work. Finally, in Section~\ref{sec:conclusion}, we present the concluding remarks. 